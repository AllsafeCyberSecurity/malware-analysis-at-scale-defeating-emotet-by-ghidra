from __main__ import *

import struct
from itertools import cycle

from ghidra.program.model.listing import CodeUnit

def xor_with_multi_bytes(enc, key):
    ''' xor enc (bytes) with key (int) and return it as string
    '''
    return ''.join([chr(ord(k) ^ ord(v)) for k, v in zip(cycle(struct.pack('<I', key)), enc)])

def decrypt_string(enc_data_addr):
    key = getInt(enc_data_addr)
    xored_length = getInt(enc_data_addr.add(4))
    original_length = key ^ xored_length
    enc = getBytes(enc_data_addr.add(8), original_length).tostring()
    return xor_with_multi_bytes(enc, key)

def add_bookmark_comment(addr, comment):
    cu = currentProgram.getListing().getCodeUnitAt(addr)
    createBookmark(addr, "decrypted_str", comment)
    cu.setComment(CodeUnit.EOL_COMMENT, comment)

def get_instructions_before(addr, n=1):
    r = []
    for _ in range(n):
        inst = getInstructionBefore(addr)
        r.append(inst)
        addr = inst.getAddress()
    return r

def is_mov_edx(inst):
    return str(inst).startswith('MOV EDX,0x')

def main():

    decrypt_string_addr = toAddr(0x1000732d)

    for xref in getReferencesTo(decrypt_string_addr):
        # get instructions before callee address
        insts = get_instructions_before(xref.getFromAddress(), 50)
        
        # find instruction that passes 
        # address of encrypted data via EDX
        for inst in insts:
            if is_mov_edx(inst):
                # get encrypted data address and decrypt it
                data_addr = inst.getAddress(1)
                if data_addr:
                    decrypted_str = decrypt_string(data_addr)
                    # add comment
                    print('[*] found at {} : {!r}'.format(inst.getAddress(), decrypted_str))
                    add_bookmark_comment(inst.getAddress(), decrypted_str)

if __name__ == '__main__':
    main()





