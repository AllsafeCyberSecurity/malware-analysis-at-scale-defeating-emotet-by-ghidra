from __main__ import *

import struct
from itertools import cycle

from ghidra.program.model.listing import CodeUnit

def decrypt_string(enc_data_addr):
    key = getInt(enc_data_addr)
    xored_length = getInt(enc_data_addr.add(4))
    original_length = key ^ xored_length
    enc = getBytes(enc_data_addr.add(8), original_length).tostring()
    return ''.join([chr(ord(k) ^ ord(v)) for k, v in zip(cycle(struct.pack('<I', key)), enc)])


def add_bookmark_comment(addr, comment):
    cu = currentProgram.getListing().getCodeUnitAt(addr)
    createBookmark(addr, "decrypted_str", comment)
    cu.setComment(CodeUnit.EOL_COMMENT, comment)

def get_instructions_before(addr, n=1):
    r = []
    for _ in range(n):
        inst = getInstructionBefore(addr)
        r.append(inst)
        addr = inst.getAddress()
    return r

def is_call(inst):
    return str(inst).startswith('CALL')

def is_mov_with_fastcall(inst):
    s_inst = str(inst)
    return s_inst.startswith('MOV EDX,0x') or s_inst.startswith('MOV ECX,0x')

def find_decrypt_string_func():
    '''
        00773675 8b d9           MOV        EBX,param_1
        00773677 2b de           SUB        EBX,ESI
        00773679 83 c3 03        ADD        EBX,0x3
        0077367c c1 eb 02        SHR        EBX,0x2
        0077367f 3b f1           CMP        ESI,param_1

    '''
    asm = '\\x8b.{1}\\x2b.{1}\\x83.{1}\\x03\\xc1.{1}\\x02\\x3b.{1}'
    found = findBytes(None, asm, -1)
    if not found:
        raise RuntimeError('decrypt_string function is not found')
    suspicious_decrypt_string_func = set([getFunctionContaining(sus_inst) for sus_inst in found])
    return list(suspicious_decrypt_string_func)

def main():
    decrypt_string_funcs = find_decrypt_string_func()
    for decrypt_string_func in decrypt_string_funcs:
        print('[*] decrypt_string at {}'.format(decrypt_string_func.getEntryPoint()))
        # get callee address of decrypt_string function
        for xref in getReferencesTo(decrypt_string_func.getEntryPoint()):
            # get instructions before callee address
            insts = get_instructions_before(xref.getFromAddress(), 50)
            
            # find instruction that passes 
            # address of encrypted data via EDX
            for inst in insts:
                if is_call(inst):
                    break
                elif is_mov_with_fastcall(inst):
                    # get encrypted data address and decrypt it
                    data_addr = inst.getOpObjects(1)[0].getValue()
                    if data_addr:
                        decrypted_str = decrypt_string(toAddr(data_addr))
                        # add comment
                        print('[*] found at {} : {!r}'.format(inst.getAddress(), decrypted_str))
                        add_bookmark_comment(inst.getAddress(), decrypted_str)
                        break


if __name__ == '__main__':
    main()





