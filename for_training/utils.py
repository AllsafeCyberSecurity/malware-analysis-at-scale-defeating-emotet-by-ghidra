from __main__ import *

from ghidra.program.model.listing import CodeUnit
from ghidra.program.model.scalar import Scalar
from ghidra.app.decompiler import DecompInterface
from ghidra.program.model.listing import CodeUnit
from ghidra.program.model.pcode import PcodeOp
from ghidra.program.model.scalar import Scalar


def add_bookmark_comment(addr, comment, name):
    cu = currentProgram.getListing().getCodeUnitAt(addr)
    createBookmark(addr, name, comment)
    cu.setComment(CodeUnit.EOL_COMMENT, comment)

def get_instructions_before(addr, n=1):
    '''get N instructions before specified address.'''
    r = []
    for _ in range(n):
        inst = getInstructionBefore(addr)
        r.append(inst)
        addr = inst.getAddress()
    return r

def decompile_func(func):
    decompiler = DecompInterface()
    decompiler.openProgram(currentProgram)
    
    results = decompiler.decompileFunction(func, 0, monitor)
    if not results.decompileCompleted():
        raise RuntimeError('failed to decompile function: {}'.format(func))

    high_func = results.getHighFunction()
    return high_func

def get_pcode_at(addr):
    caller = getFunctionContaining(addr)
    high_func = decompile_func(caller)
    pcodes = high_func.getPcodeOps(addr)
    return pcodes

def get_all_functions():
    '''get all function in program.'''
    funcs = []
    func = getFirstFunction()
    while func is not None:
        funcs.append(func)
        func = getFunctionAfter(func)
    return funcs

def get_func_xref_count(n=10):
    '''get function reference count in program.'''

    # get all functions as list
    funcs = get_all_functions()

    # get xref counts for each function
    xref_counts = [
        {'name': func.getName(), 'count': len(getReferencesTo(func.getEntryPoint()))} 
        for func in funcs
    ]

    # sort with ascending by 'count' value and get top N
    topn_called_funcs = sorted(xref_counts, key=lambda x: x['count'])[::-1][:n]
    return topn_called_funcs

def xor(key, data):
    '''xor data with multi-bytes key.'''
    return ''.join([chr(ord(k) ^ ord(d)) for k, d in zip(key, data)])

def calc_hash_case_insensitive(name, key):
    value = 0
    for c in name.lower():
        value = (ord(c) + value * 0x1003f) & 0xffffffff
    return value ^ key