from __main__ import *

import socket
import struct

SIZE_OF_IP = 4
SIZE_OF_SINGLE_CONFIG = 8

def convert_dword_to_ip(dword_ip):
    return socket.inet_ntoa(struct.pack('!I', dword_ip)).encode('utf-8')

class InvalidConfig(Exception):
    pass

def parse_single_config(addr):
    # get 4 bytes from top of the given address
    # this shuld be IP address
    ip = convert_dword_to_ip(getInt(addr))

    # '0.0.0.0' is a mark of the end of config
    if ip == '0.0.0.0':
        raise InvalidConfig('Invalid Config or found Config end')

    # get 2 bytes from offset 4 of the given address,
    # this should be port number
    port = getShort(addr.add(SIZE_OF_IP))
    return ip, port

def iterate_config(config_addr):
    while True:
        try:
            ip, port = parse_single_config(config_addr)
            config_addr = config_addr.add(SIZE_OF_SINGLE_CONFIG)
            yield (ip, port)
        except InvalidConfig:
            # when parse_single_config throw InvalidConfig exceptoin,
            # it should be that it finished iteration of config
            break
        except Exception as e:
            print('[!] {}'.format(e))

def find_config_address():
    ''' **** IMPLEMENT HERE ****

    search config embedded address and return address of it.
    Hint:
        1. use Version Tracking to configure the characteristic 
            instructions related to config
        2. use `findBytes` method to search bytes/instructions
    '''
    raise NotImplementedError('not implemented')

def extract_c2(config_addr=None):
    if config_addr is None:
        config_addr = find_config_address()
    
    print('[*] Config Address: {}'.format(config_addr))
    for (ip, port) in iterate_config(config_addr):
        print('http://{}:{}'.format(ip, port))

def main():
    extract_c2()

if __name__ == '__main__':
    main()